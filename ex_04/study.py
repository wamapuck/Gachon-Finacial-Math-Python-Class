# ✅ 파일 열기 모드(mode) 정리

# 'r' : 읽기 전용 (파일이 존재해야 함)
# 'w' : 쓰기 전용 (파일이 없으면 생성, 있으면 기존 내용 삭제)
# 'a' : 추가(append) 전용 (파일 끝에 내용 추가, 없으면 생성)
# 'x' : 배타적 생성 (파일이 존재하면 에러 발생)
# 'b' : 바이너리 모드 (텍스트 아닌 파일, 예: 이미지, 영상)
# 't' : 텍스트 모드 (기본값)
# '+' : 읽기/쓰기 겸용

# 예시 조합:
# 'rb' → 바이너리 읽기
# 'w+' → 읽기/쓰기 (기존 내용 삭제)
# 'a+' → 읽기/쓰기 (내용을 끝에 추가)
# 'r+b' → 바이너리 읽기/쓰기

# ------------------------------------------------------

# ✅ [1] open()만 사용 (가장 기본적인 방식)
f = open('file.txt', 'r')
data = f.read()
f.close()

# ⚠️ 문제점:
# 예외가 발생하면 f.close()가 호출되지 않음 → 파일이 안 닫힐 위험

# ------------------------------------------------------

# ✅ [2] open() + try ... finally (안전하게 파일을 닫는 방식)
f = open('file.txt', 'r')
try:
    data = f.read()
finally:
    f.close()

# 👍 장점:
# 예외가 발생해도 finally에서 무조건 close() 실행 → 안전함

# 👎 단점:
# 코드가 길고 복잡해짐

# ------------------------------------------------------

# ✅ [3] with open() as f: (Context Manager 방식)
with open('file.txt', 'r') as f:
    data = f.read()

# 💡 내부적으로는 위의 try...finally와 동일한 구조로 동작
# → 예외가 발생해도 자동으로 파일을 닫아줌

# 👍 장점:
# - 가장 짧고 가독성 좋음
# - 예외에도 안전
# - 실무에서 거의 항상 이 방식 사용

# ------------------------------------------------------

# 📌 커서(cursor) 또는 파일 포인터란?

# - 파일을 읽거나 쓸 때 '어디까지 읽었는지'를 기억하는 위치
# - 파일은 처음 열면 커서가 0번 인덱스(파일 맨 앞)를 가리킴
# - read(), readline() 등을 호출할수록 커서가 이동함
# - 다시 읽고 싶으면 f.seek(0) 으로 커서를 처음으로 되돌릴 수 있음

# 예시:
# f.seek(0) → 커서를 파일 맨 앞으로 이동시킴

# ------------------------------------------------------

# ✅ [1] read() : 파일 전체 내용을 문자열로 읽음
with open('file.txt', 'r') as f:
    data = f.read()

# 📌 반환값: 하나의 문자열(str)
# 📌 줄바꿈(\n)도 포함됨
# 📌 파일 크기가 클 경우 메모리 많이 사용됨
# 📌 read() 이후 커서는 파일 끝(EOF)에 위치함

# 예시 출력: '첫 줄\n둘째 줄\n셋째 줄\n'

# ------------------------------------------------------

# ✅ [2] readline() : 파일에서 한 줄만 읽음
with open('file.txt', 'r') as f:
    line1 = f.readline()
    line2 = f.readline()

# 📌 반환값: 문자열(str)
# 📌 한 번 호출할 때마다 한 줄씩 읽음 (줄바꿈 포함)
# 📌 호출할수록 커서가 한 줄씩 아래로 이동
# 📌 루프나 반복문에서 자주 사용됨

# 예시 출력: '첫 줄\n' → '둘째 줄\n'

# ------------------------------------------------------

# ✅ [3] readlines() : 파일 전체를 리스트로 읽음
with open('file.txt', 'r') as f:
    lines = f.readlines()

# 📌 반환값: 리스트(list) 안에 각 줄이 문자열로 들어있음
# 📌 각 요소는 줄 하나(str)이며 줄바꿈 포함됨
# 📌 리스트 전체가 메모리에 올라오므로 크면 주의
# 📌 커서는 역시 파일 끝으로 이동함

# 예시 출력: ['첫 줄\n', '둘째 줄\n', '셋째 줄\n']

# ------------------------------------------------------

# 📌 커서 관련 함수 요약

# f.seek(pos)
# → 파일 내 커서를 원하는 위치로 이동 (예: f.seek(0) = 맨 앞으로)

# f.tell()
# → 현재 커서의 위치(인덱스)를 반환

# ------------------------------------------------------

# 📌 핵심 비교 요약

# 1. open()만 사용
#    - 간단하지만 예외 발생 시 close() 누락 위험

# 2. open() + try...finally
#    - 안정성 확보
#    - 하지만 코드가 길고 실수 가능성 있음

# 3. with open()
#    - 안정성 + 간결함
#    - 실무/실전에서 사실상 open의 대체처럼 사용됨

# 🔁 결론:
# - 파일을 열 땐 항상 with open(...) as f: 를 사용하자!
# - 읽기 방식(read, readline, readlines)은 용도에 맞게 사용
# - 커서의 존재를 이해하고, 필요시 seek(0)으로 재조정!
# - 파일 모드는 작업 목적(읽기/쓰기/추가 등)에 따라 정확히 선택!
